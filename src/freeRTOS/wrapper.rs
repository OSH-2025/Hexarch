/* automatically generated by rust-bindgen 0.71.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TICK_TYPE_WIDTH_16_BITS: u32 = 0;
pub const TICK_TYPE_WIDTH_32_BITS: u32 = 1;
pub const TICK_TYPE_WIDTH_64_BITS: u32 = 2;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_TIME_SLICING: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_TICKLESS_IDLE: u32 = 0;
pub const configMAX_PRIORITIES: u32 = 5;
pub const configMINIMAL_STACK_SIZE: u32 = 128;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configTICK_TYPE_WIDTH_IN_BITS: u32 = 2;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 0;
pub const configUSE_MINI_LIST_ITEM: u32 = 1;
pub const configHEAP_CLEAR_MEMORY_ON_FREE: u32 = 1;
pub const configSTATS_BUFFER_MAX_LENGTH: u32 = 65535;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 4;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 128;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configUSE_EVENT_GROUPS: u32 = 1;
pub const configUSE_STREAM_BUFFERS: u32 = 1;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configTOTAL_HEAP_SIZE: u32 = 4096;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 0;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const configENABLE_HEAP_PROTECTOR: u32 = 0;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 0;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 0;
pub const configMAX_API_CALL_INTERRUPT_PRIORITY: u32 = 0;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_SB_COMPLETED_CALLBACK: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configTOTAL_MPU_REGIONS: u32 = 8;
pub const configTEX_S_C_B_FLASH: u32 = 7;
pub const configTEX_S_C_B_SRAM: u32 = 7;
pub const configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY: u32 = 1;
pub const configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS: u32 = 0;
pub const configUSE_MPU_WRAPPERS_V1: u32 = 0;
pub const configPROTECTED_KERNEL_OBJECT_POOL_SIZE: u32 = 10;
pub const configSYSTEM_CALL_STACK_SIZE: u32 = 128;
pub const configENABLE_ACCESS_CONTROL_LIST: u32 = 1;
pub const configRUN_MULTIPLE_PRIORITIES: u32 = 0;
pub const configUSE_CORE_AFFINITY: u32 = 0;
pub const configUSE_TASK_PREEMPTION_DISABLE: u32 = 0;
pub const configUSE_PASSIVE_IDLE_HOOK: u32 = 0;
pub const secureconfigMAX_SECURE_CONTEXTS: u32 = 5;
pub const configKERNEL_PROVIDED_STATIC_MEMORY: u32 = 1;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 1;
pub const configENABLE_MPU: u32 = 1;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_MVE: u32 = 1;
pub const configCHECK_HANDLER_INSTALLATION: u32 = 1;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 0;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 0;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const configUNIQUE_INTERRUPT_PRIORITIES: u32 = 16;
pub const configNUMBER_OF_CORES: u32 = 1;
pub const configASSERT_DEFINED: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u64 = 6510615555426900570;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_EAFNOSUPPORT: u32 = 97;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 16;
pub const portPRIORITY_SHIFT: u32 = 4;
pub const portMAX_BINARY_POINT_VALUE: u32 = 3;
pub const portICCPMR_PRIORITY_MASK_OFFSET: u32 = 4;
pub const portICCIAR_INTERRUPT_ACKNOWLEDGE_OFFSET: u32 = 12;
pub const portICCEOIR_END_OF_INTERRUPT_OFFSET: u32 = 16;
pub const portICCBPR_BINARY_POINT_OFFSET: u32 = 8;
pub const portICCRPR_RUNNING_PRIORITY_OFFSET: u32 = 20;
pub const portBYTE_ALIGNMENT_MASK: u32 = 15;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const configUSE_PICOLIBC_TLS: u32 = 0;
pub const configUSE_C_RUNTIME_TLS_SUPPORT: u32 = 0;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const portHAS_NESTED_INTERRUPTS: u32 = 1;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configRUN_ADDITIONAL_TESTS: u32 = 0;
pub const configENABLE_PAC: u32 = 0;
pub const configENABLE_BTI: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 9] = b"V11.1.0+\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 11;
pub const tskKERNEL_VERSION_MINOR: u32 = 1;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskMPU_READ_PERMISSION: u32 = 1;
pub const tskMPU_WRITE_PERMISSION: u32 = 2;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type TaskFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
pub type StackType_t = usize;
pub type BaseType_t = ::std::os::raw::c_long;
pub type UBaseType_t = u64;
pub type TickType_t = u64;
unsafe extern "C" {
    pub fn vPortEnterCritical();
}
unsafe extern "C" {
    pub fn vPortExitCritical();
}
unsafe extern "C" {
    pub fn uxPortSetInterruptMask() -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vPortClearInterruptMask(uxNewMaskValue: UBaseType_t);
}
unsafe extern "C" {
    pub fn vPortInstallFreeRTOSVectorTable();
}
unsafe extern "C" {
    pub fn FreeRTOS_Tick_Handler();
}
unsafe extern "C" {
    pub fn vPortTaskUsesFPU();
}
unsafe extern "C" {
    pub fn vPortValidateInterruptPriority();
}
unsafe extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::std::os::raw::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HeapRegion"][::std::mem::size_of::<HeapRegion>() - 16usize];
    ["Alignment of HeapRegion"][::std::mem::align_of::<HeapRegion>() - 8usize];
    ["Offset of field: HeapRegion::pucStartAddress"]
        [::std::mem::offset_of!(HeapRegion, pucStartAddress) - 0usize];
    ["Offset of field: HeapRegion::xSizeInBytes"]
        [::std::mem::offset_of!(HeapRegion, xSizeInBytes) - 8usize];
};
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xHeapStats {
    pub xAvailableHeapSpaceInBytes: usize,
    pub xSizeOfLargestFreeBlockInBytes: usize,
    pub xSizeOfSmallestFreeBlockInBytes: usize,
    pub xNumberOfFreeBlocks: usize,
    pub xMinimumEverFreeBytesRemaining: usize,
    pub xNumberOfSuccessfulAllocations: usize,
    pub xNumberOfSuccessfulFrees: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xHeapStats"][::std::mem::size_of::<xHeapStats>() - 56usize];
    ["Alignment of xHeapStats"][::std::mem::align_of::<xHeapStats>() - 8usize];
    ["Offset of field: xHeapStats::xAvailableHeapSpaceInBytes"]
        [::std::mem::offset_of!(xHeapStats, xAvailableHeapSpaceInBytes) - 0usize];
    ["Offset of field: xHeapStats::xSizeOfLargestFreeBlockInBytes"]
        [::std::mem::offset_of!(xHeapStats, xSizeOfLargestFreeBlockInBytes) - 8usize];
    ["Offset of field: xHeapStats::xSizeOfSmallestFreeBlockInBytes"]
        [::std::mem::offset_of!(xHeapStats, xSizeOfSmallestFreeBlockInBytes) - 16usize];
    ["Offset of field: xHeapStats::xNumberOfFreeBlocks"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfFreeBlocks) - 24usize];
    ["Offset of field: xHeapStats::xMinimumEverFreeBytesRemaining"]
        [::std::mem::offset_of!(xHeapStats, xMinimumEverFreeBytesRemaining) - 32usize];
    ["Offset of field: xHeapStats::xNumberOfSuccessfulAllocations"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfSuccessfulAllocations) - 40usize];
    ["Offset of field: xHeapStats::xNumberOfSuccessfulFrees"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfSuccessfulFrees) - 48usize];
};
pub type HeapStats_t = xHeapStats;
unsafe extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
unsafe extern "C" {
    pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
unsafe extern "C" {
    pub fn pvPortMalloc(xWantedSize: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pvPortCalloc(xNum: usize, xSize: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vPortFree(pv: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vPortInitialiseBlocks();
}
unsafe extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortResetHeapMinimumEverFreeHeapSize();
}
unsafe extern "C" {
    pub fn vPortHeapResetState();
}
unsafe extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST_ITEM"][::std::mem::size_of::<xSTATIC_LIST_ITEM>() - 40usize];
    ["Alignment of xSTATIC_LIST_ITEM"][::std::mem::align_of::<xSTATIC_LIST_ITEM>() - 8usize];
    ["Offset of field: xSTATIC_LIST_ITEM::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, xDummy2) - 0usize];
    ["Offset of field: xSTATIC_LIST_ITEM::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_MINI_LIST_ITEM"][::std::mem::size_of::<xSTATIC_MINI_LIST_ITEM>() - 24usize];
    ["Alignment of xSTATIC_MINI_LIST_ITEM"]
        [::std::mem::align_of::<xSTATIC_MINI_LIST_ITEM>() - 8usize];
    ["Offset of field: xSTATIC_MINI_LIST_ITEM::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, xDummy2) - 0usize];
    ["Offset of field: xSTATIC_MINI_LIST_ITEM::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut ::std::os::raw::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST"][::std::mem::size_of::<xSTATIC_LIST>() - 40usize];
    ["Alignment of xSTATIC_LIST"][::std::mem::align_of::<xSTATIC_LIST>() - 8usize];
    ["Offset of field: xSTATIC_LIST::uxDummy2"]
        [::std::mem::offset_of!(xSTATIC_LIST, uxDummy2) - 0usize];
    ["Offset of field: xSTATIC_LIST::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_LIST, pvDummy3) - 8usize];
    ["Offset of field: xSTATIC_LIST::xDummy4"]
        [::std::mem::offset_of!(xSTATIC_LIST, xDummy4) - 16usize];
};
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::std::os::raw::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::std::os::raw::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummy12: [UBaseType_t; 2usize],
    pub ulDummy18: [u32; 1usize],
    pub ucDummy19: [u8; 1usize],
    pub uxDummy20: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TCB"][::std::mem::size_of::<xSTATIC_TCB>() - 144usize];
    ["Alignment of xSTATIC_TCB"][::std::mem::align_of::<xSTATIC_TCB>() - 8usize];
    ["Offset of field: xSTATIC_TCB::pxDummy1"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy1) - 0usize];
    ["Offset of field: xSTATIC_TCB::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_TCB, xDummy3) - 8usize];
    ["Offset of field: xSTATIC_TCB::uxDummy5"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy5) - 88usize];
    ["Offset of field: xSTATIC_TCB::pxDummy6"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy6) - 96usize];
    ["Offset of field: xSTATIC_TCB::ucDummy7"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy7) - 104usize];
    ["Offset of field: xSTATIC_TCB::uxDummy12"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy12) - 120usize];
    ["Offset of field: xSTATIC_TCB::ulDummy18"]
        [::std::mem::offset_of!(xSTATIC_TCB, ulDummy18) - 136usize];
    ["Offset of field: xSTATIC_TCB::ucDummy19"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy19) - 140usize];
    ["Offset of field: xSTATIC_TCB::uxDummy20"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy20) - 141usize];
};
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::std::os::raw::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub ucDummy6: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::std::os::raw::c_void,
    pub uxDummy2: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_QUEUE__bindgen_ty_1"]
        [::std::mem::size_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    ["Alignment of xSTATIC_QUEUE__bindgen_ty_1"]
        [::std::mem::align_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    ["Offset of field: xSTATIC_QUEUE__bindgen_ty_1::pvDummy2"]
        [::std::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, pvDummy2) - 0usize];
    ["Offset of field: xSTATIC_QUEUE__bindgen_ty_1::uxDummy2"]
        [::std::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, uxDummy2) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_QUEUE"][::std::mem::size_of::<xSTATIC_QUEUE>() - 144usize];
    ["Alignment of xSTATIC_QUEUE"][::std::mem::align_of::<xSTATIC_QUEUE>() - 8usize];
    ["Offset of field: xSTATIC_QUEUE::pvDummy1"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, pvDummy1) - 0usize];
    ["Offset of field: xSTATIC_QUEUE::u"][::std::mem::offset_of!(xSTATIC_QUEUE, u) - 24usize];
    ["Offset of field: xSTATIC_QUEUE::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, xDummy3) - 32usize];
    ["Offset of field: xSTATIC_QUEUE::uxDummy4"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, uxDummy4) - 112usize];
    ["Offset of field: xSTATIC_QUEUE::ucDummy5"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, ucDummy5) - 136usize];
    ["Offset of field: xSTATIC_QUEUE::ucDummy6"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, ucDummy6) - 138usize];
};
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub ucDummy4: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_EVENT_GROUP"][::std::mem::size_of::<xSTATIC_EVENT_GROUP>() - 56usize];
    ["Alignment of xSTATIC_EVENT_GROUP"][::std::mem::align_of::<xSTATIC_EVENT_GROUP>() - 8usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::xDummy1"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy1) - 0usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy2) - 8usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::ucDummy4"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, ucDummy4) - 48usize];
};
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::std::os::raw::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut ::std::os::raw::c_void,
    pub pvDummy6: TaskFunction_t,
    pub ucDummy8: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TIMER"][::std::mem::size_of::<xSTATIC_TIMER>() - 80usize];
    ["Alignment of xSTATIC_TIMER"][::std::mem::align_of::<xSTATIC_TIMER>() - 8usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy1"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy1) - 0usize];
    ["Offset of field: xSTATIC_TIMER::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_TIMER, xDummy2) - 8usize];
    ["Offset of field: xSTATIC_TIMER::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_TIMER, xDummy3) - 48usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy5"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy5) - 56usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy6"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy6) - 64usize];
    ["Offset of field: xSTATIC_TIMER::ucDummy8"]
        [::std::mem::offset_of!(xSTATIC_TIMER, ucDummy8) - 72usize];
};
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [usize; 4usize],
    pub pvDummy2: [*mut ::std::os::raw::c_void; 3usize],
    pub ucDummy3: u8,
    pub uxDummy6: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_STREAM_BUFFER"][::std::mem::size_of::<xSTATIC_STREAM_BUFFER>() - 72usize];
    ["Alignment of xSTATIC_STREAM_BUFFER"]
        [::std::mem::align_of::<xSTATIC_STREAM_BUFFER>() - 8usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::uxDummy1"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy1) - 0usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::pvDummy2"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, pvDummy2) - 32usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::ucDummy3"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, ucDummy3) - 56usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::uxDummy6"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy6) - 64usize];
};
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    #[doc = "< The value being listed.  In most cases this is used to sort the list in ascending order."]
    pub xItemValue: TickType_t,
    #[doc = "< Pointer to the next ListItem_t in the list."]
    pub pxNext: *mut xLIST_ITEM,
    #[doc = "< Pointer to the previous ListItem_t in the list."]
    pub pxPrevious: *mut xLIST_ITEM,
    #[doc = "< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself."]
    pub pvOwner: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to the list in which this list item is placed (if any)."]
    pub pxContainer: *mut xLIST,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST_ITEM"][::std::mem::size_of::<xLIST_ITEM>() - 40usize];
    ["Alignment of xLIST_ITEM"][::std::mem::align_of::<xLIST_ITEM>() - 8usize];
    ["Offset of field: xLIST_ITEM::xItemValue"]
        [::std::mem::offset_of!(xLIST_ITEM, xItemValue) - 0usize];
    ["Offset of field: xLIST_ITEM::pxNext"][::std::mem::offset_of!(xLIST_ITEM, pxNext) - 8usize];
    ["Offset of field: xLIST_ITEM::pxPrevious"]
        [::std::mem::offset_of!(xLIST_ITEM, pxPrevious) - 16usize];
    ["Offset of field: xLIST_ITEM::pvOwner"][::std::mem::offset_of!(xLIST_ITEM, pvOwner) - 24usize];
    ["Offset of field: xLIST_ITEM::pxContainer"]
        [::std::mem::offset_of!(xLIST_ITEM, pxContainer) - 32usize];
};
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMINI_LIST_ITEM"][::std::mem::size_of::<xMINI_LIST_ITEM>() - 24usize];
    ["Alignment of xMINI_LIST_ITEM"][::std::mem::align_of::<xMINI_LIST_ITEM>() - 8usize];
    ["Offset of field: xMINI_LIST_ITEM::xItemValue"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, xItemValue) - 0usize];
    ["Offset of field: xMINI_LIST_ITEM::pxNext"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, pxNext) - 8usize];
    ["Offset of field: xMINI_LIST_ITEM::pxPrevious"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, pxPrevious) - 16usize];
};
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    #[doc = "< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY ()."]
    pub pxIndex: *mut ListItem_t,
    #[doc = "< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker."]
    pub xListEnd: MiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST"][::std::mem::size_of::<xLIST>() - 40usize];
    ["Alignment of xLIST"][::std::mem::align_of::<xLIST>() - 8usize];
    ["Offset of field: xLIST::uxNumberOfItems"]
        [::std::mem::offset_of!(xLIST, uxNumberOfItems) - 0usize];
    ["Offset of field: xLIST::pxIndex"][::std::mem::offset_of!(xLIST, pxIndex) - 8usize];
    ["Offset of field: xLIST::xListEnd"][::std::mem::offset_of!(xLIST, xListEnd) - 16usize];
};
pub type List_t = xLIST;
unsafe extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
unsafe extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h\n\n Type by which tasks are referenced.  For example, a call to xTaskCreate\n returns (via a pointer parameter) an TaskHandle_t variable that can then\n be used as a parameter to vTaskDelete to delete the task.\n\n \\defgroup TaskHandle_t TaskHandle_t\n \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type ConstTaskHandle_t = *const tskTaskControlBlock;
pub type TaskHookFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = ::std::os::raw::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTIME_OUT"][::std::mem::size_of::<xTIME_OUT>() - 16usize];
    ["Alignment of xTIME_OUT"][::std::mem::align_of::<xTIME_OUT>() - 8usize];
    ["Offset of field: xTIME_OUT::xOverflowCount"]
        [::std::mem::offset_of!(xTIME_OUT, xOverflowCount) - 0usize];
    ["Offset of field: xTIME_OUT::xTimeOnEntering"]
        [::std::mem::offset_of!(xTIME_OUT, xTimeOnEntering) - 8usize];
};
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::std::os::raw::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMEMORY_REGION"][::std::mem::size_of::<xMEMORY_REGION>() - 16usize];
    ["Alignment of xMEMORY_REGION"][::std::mem::align_of::<xMEMORY_REGION>() - 8usize];
    ["Offset of field: xMEMORY_REGION::pvBaseAddress"]
        [::std::mem::offset_of!(xMEMORY_REGION, pvBaseAddress) - 0usize];
    ["Offset of field: xMEMORY_REGION::ulLengthInBytes"]
        [::std::mem::offset_of!(xMEMORY_REGION, ulLengthInBytes) - 8usize];
    ["Offset of field: xMEMORY_REGION::ulParameters"]
        [::std::mem::offset_of!(xMEMORY_REGION, ulParameters) - 12usize];
};
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::std::os::raw::c_char,
    pub usStackDepth: usize,
    pub pvParameters: *mut ::std::os::raw::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_PARAMETERS"][::std::mem::size_of::<xTASK_PARAMETERS>() - 64usize];
    ["Alignment of xTASK_PARAMETERS"][::std::mem::align_of::<xTASK_PARAMETERS>() - 8usize];
    ["Offset of field: xTASK_PARAMETERS::pvTaskCode"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pvTaskCode) - 0usize];
    ["Offset of field: xTASK_PARAMETERS::pcName"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pcName) - 8usize];
    ["Offset of field: xTASK_PARAMETERS::usStackDepth"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, usStackDepth) - 16usize];
    ["Offset of field: xTASK_PARAMETERS::pvParameters"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pvParameters) - 24usize];
    ["Offset of field: xTASK_PARAMETERS::uxPriority"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, uxPriority) - 32usize];
    ["Offset of field: xTASK_PARAMETERS::puxStackBuffer"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, puxStackBuffer) - 40usize];
    ["Offset of field: xTASK_PARAMETERS::xRegions"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, xRegions) - 48usize];
};
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const ::std::os::raw::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_STATUS"][::std::mem::size_of::<xTASK_STATUS>() - 72usize];
    ["Alignment of xTASK_STATUS"][::std::mem::align_of::<xTASK_STATUS>() - 8usize];
    ["Offset of field: xTASK_STATUS::xHandle"]
        [::std::mem::offset_of!(xTASK_STATUS, xHandle) - 0usize];
    ["Offset of field: xTASK_STATUS::pcTaskName"]
        [::std::mem::offset_of!(xTASK_STATUS, pcTaskName) - 8usize];
    ["Offset of field: xTASK_STATUS::xTaskNumber"]
        [::std::mem::offset_of!(xTASK_STATUS, xTaskNumber) - 16usize];
    ["Offset of field: xTASK_STATUS::eCurrentState"]
        [::std::mem::offset_of!(xTASK_STATUS, eCurrentState) - 24usize];
    ["Offset of field: xTASK_STATUS::uxCurrentPriority"]
        [::std::mem::offset_of!(xTASK_STATUS, uxCurrentPriority) - 32usize];
    ["Offset of field: xTASK_STATUS::uxBasePriority"]
        [::std::mem::offset_of!(xTASK_STATUS, uxBasePriority) - 40usize];
    ["Offset of field: xTASK_STATUS::ulRunTimeCounter"]
        [::std::mem::offset_of!(xTASK_STATUS, ulRunTimeCounter) - 48usize];
    ["Offset of field: xTASK_STATUS::pxStackBase"]
        [::std::mem::offset_of!(xTASK_STATUS, pxStackBase) - 56usize];
    ["Offset of field: xTASK_STATUS::usStackHighWaterMark"]
        [::std::mem::offset_of!(xTASK_STATUS, usStackHighWaterMark) - 64usize];
};
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::std::os::raw::c_char,
        uxStackDepth: usize,
        pvParameters: *mut ::std::os::raw::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskCreateStatic(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::std::os::raw::c_char,
        uxStackDepth: usize,
        pvParameters: *mut ::std::os::raw::c_void,
        uxPriority: UBaseType_t,
        puxStackBuffer: *mut StackType_t,
        pxTaskBuffer: *mut StaticTask_t,
    ) -> TaskHandle_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskDelete( TaskHandle_t xTaskToDelete );\n @endcode\n\n INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Remove a task from the RTOS real time kernel's management.  The task being\n deleted will be removed from all ready, blocked, suspended and event lists.\n\n NOTE:  The idle task is responsible for freeing the kernel allocated\n memory from tasks that have been deleted.  It is therefore important that\n the idle task is not starved of microcontroller processing time if your\n application makes any calls to vTaskDelete ().  Memory allocated by the\n task code is not automatically freed, and should be freed before the task\n is deleted.\n\n See the demo application file death.c for sample code that utilises\n vTaskDelete ().\n\n @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n cause the calling task to be deleted.\n\n Example usage:\n @code{c}\n void vOtherFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create the task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // Use the handle to delete the task.\n   vTaskDelete( xHandle );\n }\n @endcode\n \\defgroup vTaskDelete vTaskDelete\n \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskDelay( const TickType_t xTicksToDelay );\n @endcode\n\n Delay a task for a given number of ticks.  The actual time that the\n task remains blocked depends on the tick rate.  The constant\n portTICK_PERIOD_MS can be used to calculate real time from the tick\n rate - with the resolution of one tick period.\n\n INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n\n vTaskDelay() specifies a time at which the task wishes to unblock relative to\n the time at which vTaskDelay() is called.  For example, specifying a block\n period of 100 ticks will cause the task to unblock 100 ticks after\n vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n of controlling the frequency of a periodic task as the path taken through the\n code, as well as other task and interrupt activity, will affect the frequency\n at which vTaskDelay() gets called and therefore the time at which the task\n next executes.  See xTaskDelayUntil() for an alternative API function designed\n to facilitate fixed frequency execution.  It does this by specifying an\n absolute time (rather than a relative time) at which the calling task should\n unblock.\n\n @param xTicksToDelay The amount of time, in tick periods, that\n the calling task should block.\n\n Example usage:\n\n void vTaskFunction( void * pvParameters )\n {\n // Block for 500ms.\n const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n\n   for( ;; )\n   {\n       // Simply toggle the LED every 500ms, blocking between each toggle.\n       vToggleLED();\n       vTaskDelay( xDelay );\n   }\n }\n\n \\defgroup vTaskDelay vTaskDelay\n \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );\n @endcode\n\n INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Delay a task until a specified time.  This function can be used by periodic\n tasks to ensure a constant execution frequency.\n\n This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n cause a task to block for the specified number of ticks from the time vTaskDelay () is\n called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n execution frequency as the time between a task starting to execute and that task\n calling vTaskDelay () may not be fixed [the task may take a different path though the\n code between calls, or may get interrupted or preempted a different number of times\n each time it executes].\n\n Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n unblock.\n\n The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a\n time specified in milliseconds with a resolution of one tick period.\n\n @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n task was last unblocked.  The variable must be initialised with the current time\n prior to its first use (see the example below).  Following this the variable is\n automatically updated within xTaskDelayUntil ().\n\n @param xTimeIncrement The cycle time period.  The task will be unblocked at\n time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the\n same xTimeIncrement parameter value will cause the task to execute with\n a fixed interface period.\n\n @return Value which can be used to check whether the task was actually delayed.\n Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not\n be delayed if the next expected wake time is in the past.\n\n Example usage:\n @code{c}\n // Perform an action every 10 ticks.\n void vTaskFunction( void * pvParameters )\n {\n TickType_t xLastWakeTime;\n const TickType_t xFrequency = 10;\n BaseType_t xWasDelayed;\n\n     // Initialise the xLastWakeTime variable with the current time.\n     xLastWakeTime = xTaskGetTickCount ();\n     for( ;; )\n     {\n         // Wait for the next cycle.\n         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );\n\n         // Perform action here. xWasDelayed value can be used to determine\n         // whether a deadline was missed if the code here took too long.\n     }\n }\n @endcode\n \\defgroup xTaskDelayUntil xTaskDelayUntil\n \\ingroup TaskCtrl"]
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );\n @endcode\n\n INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Obtain the priority of any task.\n\n @param xTask Handle of the task to be queried.  Passing a NULL\n handle results in the priority of the calling task being returned.\n\n @return The priority of xTask.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to obtain the priority of the created task.\n   // It was created with tskIDLE_PRIORITY, but may have changed\n   // it itself.\n   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n   {\n       // The task has changed it's priority.\n   }\n\n   // ...\n\n   // Is our priority higher than the created task?\n   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n   {\n       // Our priority (obtained using NULL handle) is higher.\n   }\n }\n @endcode\n \\defgroup uxTaskPriorityGet uxTaskPriorityGet\n \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );\n @endcode\n\n A version of uxTaskPriorityGet() that can be used from an ISR."]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n UBaseType_t uxTaskBasePriorityGet( const TaskHandle_t xTask );\n @endcode\n\n INCLUDE_uxTaskPriorityGet and configUSE_MUTEXES must be defined as 1 for this\n function to be available. See the configuration section for more information.\n\n Obtain the base priority of any task.\n\n @param xTask Handle of the task to be queried.  Passing a NULL\n handle results in the base priority of the calling task being returned.\n\n @return The base priority of xTask.\n\n \\defgroup uxTaskPriorityGet uxTaskBasePriorityGet\n \\ingroup TaskCtrl"]
    pub fn uxTaskBasePriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n UBaseType_t uxTaskBasePriorityGetFromISR( const TaskHandle_t xTask );\n @endcode\n\n A version of uxTaskBasePriorityGet() that can be used from an ISR."]
    pub fn uxTaskBasePriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );\n @endcode\n\n INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Set the priority of any task.\n\n A context switch will occur before the function returns if the priority\n being set is higher than the currently executing task.\n\n @param xTask Handle to the task for which the priority is being set.\n Passing a NULL handle results in the priority of the calling task being set.\n\n @param uxNewPriority The priority to which the task will be set.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to raise the priority of the created task.\n   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n\n   // ...\n\n   // Use a NULL handle to raise our priority to the same value.\n   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n }\n @endcode\n \\defgroup vTaskPrioritySet vTaskPrioritySet\n \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskSuspend( TaskHandle_t xTaskToSuspend );\n @endcode\n\n INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Suspend any task.  When suspended a task will never get any microcontroller\n processing time, no matter what its priority.\n\n Calls to vTaskSuspend are not accumulative -\n i.e. calling vTaskSuspend () twice on the same task still only requires one\n call to vTaskResume () to ready the suspended task.\n\n @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n handle will cause the calling task to be suspended.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Suspend ourselves.\n   vTaskSuspend( NULL );\n\n   // We cannot get here unless another task calls vTaskResume\n   // with our handle as the parameter.\n }\n @endcode\n \\defgroup vTaskSuspend vTaskSuspend\n \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskResume( TaskHandle_t xTaskToResume );\n @endcode\n\n INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Resumes a suspended task.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n vTaskResume ().\n\n @param xTaskToResume Handle to the task being readied.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Resume the suspended task ourselves.\n   vTaskResume( xHandle );\n\n   // The created task will once again get microcontroller processing\n   // time in accordance with its priority within the system.\n }\n @endcode\n \\defgroup vTaskResume vTaskResume\n \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void xTaskResumeFromISR( TaskHandle_t xTaskToResume );\n @endcode\n\n INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n available.  See the configuration section for more information.\n\n An implementation of vTaskResume() that can be called from within an ISR.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n xTaskResumeFromISR ().\n\n xTaskResumeFromISR() should not be used to synchronise a task with an\n interrupt if there is a chance that the interrupt could arrive prior to the\n task being suspended - as this can lead to interrupts being missed. Use of a\n semaphore as a synchronisation mechanism would avoid this eventuality.\n\n @param xTaskToResume Handle to the task being readied.\n\n @return pdTRUE if resuming the task should result in a context switch,\n otherwise pdFALSE. This is used by the ISR to determine if a context switch\n may be required following the ISR.\n\n \\defgroup vTaskResumeFromISR vTaskResumeFromISR\n \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskStartScheduler( void );\n @endcode\n\n Starts the real time kernel tick processing.  After calling the kernel\n has control over which tasks are executed and when.\n\n See the demo application file main.c for an example of creating\n tasks and starting the kernel.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will not get here unless a task calls vTaskEndScheduler ()\n }\n @endcode\n\n \\defgroup vTaskStartScheduler vTaskStartScheduler\n \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskEndScheduler( void );\n @endcode\n\n NOTE:  At the time of writing only the x86 real mode port, which runs on a PC\n in place of DOS, implements this function.\n\n Stops the real time kernel tick.  All created tasks will be automatically\n deleted and multitasking (either preemptive or cooperative) will\n stop.  Execution then resumes from the point where vTaskStartScheduler ()\n was called, as if vTaskStartScheduler () had just returned.\n\n See the demo application file main. c in the demo/PC directory for an\n example that uses vTaskEndScheduler ().\n\n vTaskEndScheduler () requires an exit function to be defined within the\n portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n performs hardware specific operations such as stopping the kernel tick.\n\n vTaskEndScheduler () will cause all of the resources allocated by the\n kernel to be freed - but will not free resources allocated by application\n tasks.\n\n Example usage:\n @code{c}\n void vTaskCode( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // At some point we want to end the real time kernel processing\n       // so call ...\n       vTaskEndScheduler ();\n   }\n }\n\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will only get here when the vTaskCode () task has called\n   // vTaskEndScheduler ().  When we get here we are back to single task\n   // execution.\n }\n @endcode\n\n \\defgroup vTaskEndScheduler vTaskEndScheduler\n \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskSuspendAll( void );\n @endcode\n\n Suspends the scheduler without disabling interrupts.  Context switches will\n not occur while the scheduler is suspended.\n\n After calling vTaskSuspendAll () the calling task will continue to execute\n without risk of being swapped out until a call to xTaskResumeAll () has been\n made.\n\n API functions that have the potential to cause a context switch (for example,\n xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n is suspended.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the kernel\n       // tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.\n       xTaskResumeAll ();\n   }\n }\n @endcode\n \\defgroup vTaskSuspendAll vTaskSuspendAll\n \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskResumeAll( void );\n @endcode\n\n Resumes scheduler activity after it was suspended by a call to\n vTaskSuspendAll().\n\n xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n that were previously suspended by a call to vTaskSuspend().\n\n @return If resuming the scheduler caused a context switch then pdTRUE is\n         returned, otherwise pdFALSE is returned.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the real\n       // time kernel tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.  We want to force\n       // a context switch - but there is no point if resuming the scheduler\n       // caused a context switch already.\n       if( !xTaskResumeAll () )\n       {\n            taskYIELD ();\n       }\n   }\n }\n @endcode\n \\defgroup xTaskResumeAll xTaskResumeAll\n \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n TickType_t xTaskGetTickCount( void );\n @endcode\n\n @return The count of ticks since vTaskStartScheduler was called.\n\n \\defgroup xTaskGetTickCount xTaskGetTickCount\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n TickType_t xTaskGetTickCountFromISR( void );\n @endcode\n\n @return The count of ticks since vTaskStartScheduler was called.\n\n This is a version of xTaskGetTickCount() that is safe to be called from an\n ISR - provided that TickType_t is the natural word size of the\n microcontroller being used or interrupt nesting is either not supported or\n not being used.\n\n \\defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n uint16_t uxTaskGetNumberOfTasks( void );\n @endcode\n\n @return The number of tasks that the real time kernel is currently managing.\n This includes all ready, blocked and suspended tasks.  A task that\n has been deleted but not yet freed by the idle task will also be\n included in the count.\n\n \\defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks\n \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n char *pcTaskGetName( TaskHandle_t xTaskToQuery );\n @endcode\n\n @return The text (human readable) name of the task referenced by the handle\n xTaskToQuery.  A task can query its own name by either passing in its own\n handle, or by setting xTaskToQuery to NULL.\n\n \\defgroup pcTaskGetName pcTaskGetName\n \\ingroup TaskUtils"]
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn xTaskGetStaticBuffers(
        xTask: TaskHandle_t,
        ppuxStackBuffer: *mut *mut StackType_t,
        ppxTaskBuffer: *mut *mut StaticTask_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vApplicationStackOverflowHook(
        xTask: TaskHandle_t,
        pcTaskName: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE * puxIdleTaskStackSize )\n @endcode\n\n This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer\n @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task\n @param puxIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetIdleTaskMemory(
        ppxIdleTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxIdleTaskStackBuffer: *mut *mut StackType_t,
        puxIdleTaskStackSize: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );\n BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n @endcode\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Sends a direct to task notification to a task, with an optional value and\n action.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to\n [optionally] block to wait for a notification to be pending.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotify() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()\n with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does\n not have this parameter and always sends notifications to index 0.\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The target notification value is bitwise ORed with ulValue.\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eIncrement -\n The target notification value is incremented.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The target notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification at the\n same array index (the task already had a notification pending at that index).\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending at the\n same array index then the target notification value is set to ulValue and\n xTaskNotifyIndexed() will return pdPASS.  If the task being notified already\n had a notification pending at the same array index then no action is\n performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification at the specified array index without the\n notification value at that index being updated.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n pulPreviousNotificationValue -\n Can be used to pass out the subject task's notification value before any\n bits are modified by the notify function.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n \\defgroup xTaskNotifyIndexed xTaskNotifyIndexed\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n A version of xTaskNotifyIndexed() that can be used from an interrupt service\n routine (ISR).\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyFromISR() is equivalent to calling\n xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()\n does not have this parameter and always sends notifications to index 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The task's notification value is bitwise ORed with ulValue.  xTaskNotify()\n always returns pdPASS in this case.\n\n eIncrement -\n The task's notification value is incremented.  ulValue is not used and\n xTaskNotify() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The task's notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification (the\n task already had a notification pending).  xTaskNotify() always returns\n pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending then\n the task's notification value is set to ulValue and xTaskNotify() will\n return pdPASS.  If the task being notified already had a notification\n pending then no action is performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification without its notification value being\n updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n this case.\n\n @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n \\defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n @endcode\n\n Waits for a direct to task notification to be pending at a given index within\n an array of direct to task notifications.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyWait() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotifyWait() is equivalent to calling\n xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be received.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does\n not have this parameter and always waits for notifications on index 0.\n\n @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n will be cleared in the calling task's notification value before the task\n checks to see if any notifications are pending, and optionally blocks if no\n notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n limits.h is included) or 0xffffffffU (if limits.h is not included) will have\n the effect of resetting the task's notification value to 0.  Setting\n ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n\n @param ulBitsToClearOnExit If a notification is pending or received before\n the calling task exits the xTaskNotifyWait() function then the task's\n notification value (see the xTaskNotify() API function) is passed out using\n the pulNotificationValue parameter.  Then any bits that are set in\n ulBitsToClearOnExit will be cleared in the task's notification value (note\n *pulNotificationValue is set before any bits are cleared).  Setting\n ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n (if limits.h is not included) will have the effect of resetting the task's\n notification value to 0 before the function exits.  Setting\n ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n when the function exits (in which case the value passed out in\n pulNotificationValue will match the task's notification value).\n\n @param pulNotificationValue Used to pass the task's notification value out\n of the function.  Note the value passed out will not be effected by the\n clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for a notification to be received, should a notification\n not already be pending when xTaskNotifyWait() was called.  The task\n will not consume any processing time while it is in the Blocked state.  This\n is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be\n used to convert a time specified in milliseconds to a time specified in\n ticks.\n\n @return If a notification was received (including notifications that were\n already pending when xTaskNotifyWait was called) then pdPASS is\n returned.  Otherwise pdFAIL is returned.\n\n \\defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n\n A version of xTaskNotifyGiveIndexed() that can be called from an interrupt\n service routine (ISR).\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications\n are used as light weight and faster binary or counting semaphore equivalents.\n Actual FreeRTOS semaphores are given from an ISR using the\n xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n a task notification is vTaskNotifyGiveIndexedFromISR().\n\n When task notifications are being used as a binary or counting semaphore\n equivalent then the task being notified should wait for the notification\n using the ulTaskNotifyTakeIndexed() API function rather than the\n xTaskNotifyWaitIndexed() API function.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling\n xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n xTaskNotifyGiveFromISR() does not have this parameter and always sends\n notifications to index 0.\n\n @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n should be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n \\defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR\n \\ingroup TaskNotifications"]
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n @endcode\n\n Waits for a direct to task notification on a particular index in the calling\n task's notification array in a manner similar to taking a counting semaphore.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n ulTaskNotifyTakeIndexed() is intended for use when a task notification is\n used as a faster and lighter weight binary or counting semaphore alternative.\n Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,\n the equivalent action that instead uses a task notification is\n ulTaskNotifyTakeIndexed().\n\n When a task is using its notification value as a binary or counting semaphore\n other tasks should send notifications to it using the xTaskNotifyGiveIndexed()\n macro, or xTaskNotifyIndex() function with the eAction parameter set to\n eIncrement.\n\n ulTaskNotifyTakeIndexed() can either clear the task's notification value at\n the array index specified by the uxIndexToWaitOn parameter to zero on exit,\n in which case the notification value acts like a binary semaphore, or\n decrement the notification value on exit, in which case the notification\n value acts like a counting semaphore.\n\n A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for\n a notification.  The task does not consume any CPU time while it is in the\n Blocked state.\n\n Where as xTaskNotifyWaitIndexed() will return when a notification is pending,\n ulTaskNotifyTakeIndexed() will return when the task's notification value is\n not zero.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyTake() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling ulTaskNotifyTake() is equivalent to calling\n ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be non-zero.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does\n not have this parameter and always waits for notifications on index 0.\n\n @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n notification value is decremented when the function exits.  In this way the\n notification value acts like a counting semaphore.  If xClearCountOnExit is\n not pdFALSE then the task's notification value is cleared to zero when the\n function exits.  In this way the notification value acts like a binary\n semaphore.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for the task's notification value to be greater than zero,\n should the count not already be greater than zero when\n ulTaskNotifyTake() was called.  The task will not consume any processing\n time while it is in the Blocked state.  This is specified in kernel ticks,\n the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time\n specified in milliseconds to a time specified in ticks.\n\n @return The task's notification count before it is either cleared to zero or\n decremented (see the xClearCountOnExit parameter).\n\n \\defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed\n \\ingroup TaskNotifications"]
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );\n\n BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );\n @endcode\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n If a notification is sent to an index within the array of notifications then\n the notification at that index is said to be 'pending' until it is read or\n explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()\n is the function that clears a pending notification without reading the\n notification value.  The notification value at the same array index is not\n altered.  Set xTask to NULL to clear the notification state of the calling\n task.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyStateClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyStateClear() is equivalent to calling\n xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have a notification state\n cleared.  Set xTask to NULL to clear a notification state in the calling\n task.  To obtain a task's handle create the task using xTaskCreate() and\n make use of the pxCreatedTask parameter, or create the task using\n xTaskCreateStatic() and store the returned value, or use the task's name in\n a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values to act upon.  For example, setting uxIndexToClear to 1\n will clear the state of the notification at index 1 within the array.\n uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyStateClear() does not have this parameter and always acts on the\n notification at index 0.\n\n @return pdTRUE if the task's notification state was set to\n eNotWaitingNotification, otherwise pdFALSE.\n\n \\defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task. h\n @code{c}\n uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );\n\n uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );\n @endcode\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n ulTaskNotifyValueClearIndexed() clears the bits specified by the\n ulBitsToClear bit mask in the notification value at array index uxIndexToClear\n of the task referenced by xTask.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyValueClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling ulTaskNotifyValueClear() is equivalent to calling\n ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have bits in one of its\n notification values cleared. Set xTask to NULL to clear bits in a\n notification value of the calling task.  To obtain a task's handle create the\n task using xTaskCreate() and make use of the pxCreatedTask parameter, or\n create the task using xTaskCreateStatic() and store the returned value, or\n use the task's name in a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values in which to clear the bits.  uxIndexToClear\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyValueClear() does not have this parameter and always clears bits\n in the notification value at index 0.\n\n @param ulBitsToClear Bit mask of the bits to clear in the notification value of\n xTask. Set a bit to 1 to clear the corresponding bits in the task's notification\n value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear\n the notification value to 0.  Set ulBitsToClear to 0 to query the task's\n notification value without clearing any bits.\n\n\n @return The value of the target task's notification value before the bits\n specified by ulBitsToClear were cleared.\n \\defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear\n \\ingroup TaskNotifications"]
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );\n @endcode\n\n Capture the current time for future use with xTaskCheckForTimeOut().\n\n @param pxTimeOut Pointer to a timeout object into which the current time\n is to be captured.  The captured time includes the tick count and the number\n of times the tick count has overflowed since the system first booted.\n \\defgroup vTaskSetTimeOutState vTaskSetTimeOutState\n \\ingroup TaskCtrl"]
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );\n @endcode\n\n Determines if pxTicksToWait ticks has passed since a time was captured\n using a call to vTaskSetTimeOutState().  The captured time includes the tick\n count and the number of times the tick count has overflowed.\n\n @param pxTimeOut The time status as captured previously using\n vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated\n to reflect the current time status.\n @param pxTicksToWait The number of ticks to check for timeout i.e. if\n pxTicksToWait ticks have passed since pxTimeOut was last updated (either by\n vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.\n If the timeout has not occurred, pxTicksToWait is updated to reflect the\n number of remaining ticks.\n\n @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is\n returned and pxTicksToWait is updated to reflect the number of remaining\n ticks.\n\n @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html\n\n Example Usage:\n @code{c}\n  // Driver library function used to receive uxWantedBytes from an Rx buffer\n  // that is filled by a UART interrupt. If there are not enough bytes in the\n  // Rx buffer then the task enters the Blocked state until it is notified that\n  // more data has been placed into the buffer. If there is still not enough\n  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()\n  // is used to re-calculate the Block time to ensure the total amount of time\n  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This\n  // continues until either the buffer contains at least uxWantedBytes bytes,\n  // or the total amount of time spent in the Blocked state reaches\n  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are\n  // available up to a maximum of uxWantedBytes.\n\n  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )\n  {\n  size_t uxReceived = 0;\n  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;\n  TimeOut_t xTimeOut;\n\n      // Initialize xTimeOut.  This records the time at which this function\n      // was entered.\n      vTaskSetTimeOutState( &xTimeOut );\n\n      // Loop until the buffer contains the wanted number of bytes, or a\n      // timeout occurs.\n      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )\n      {\n          // The buffer didn't contain enough data so this task is going to\n          // enter the Blocked state. Adjusting xTicksToWait to account for\n          // any time that has been spent in the Blocked state within this\n          // function so far to ensure the total amount of time spent in the\n          // Blocked state does not exceed MAX_TIME_TO_WAIT.\n          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )\n          {\n              //Timed out before the wanted number of bytes were available,\n              // exit the loop.\n              break;\n          }\n\n          // Wait for a maximum of xTicksToWait ticks to be notified that the\n          // receive interrupt has placed more data into the buffer.\n          ulTaskNotifyTake( pdTRUE, xTicksToWait );\n      }\n\n      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.\n      // The actual number of bytes read (which might be less than\n      // uxWantedBytes) is returned.\n      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,\n                                                  pucBuffer,\n                                                  uxWantedBytes );\n\n      return uxReceived;\n  }\n @endcode\n \\defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut\n \\ingroup TaskCtrl"]
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );\n @endcode\n\n This function corrects the tick count value after the application code has held\n interrupts disabled for an extended period resulting in tick interrupts having\n been missed.\n\n This function is similar to vTaskStepTick(), however, unlike\n vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a\n time at which a task should be removed from the blocked state.  That means\n tasks may have to be removed from the blocked state as the tick count is\n moved.\n\n @param xTicksToCatchUp The number of tick interrupts that have been missed due to\n interrupts being disabled.  Its value is not computed automatically, so must be\n computed by the application writer.\n\n @return pdTRUE if moving the tick count forward resulted in a task leaving the\n blocked state and a context switch being performed.  Otherwise pdFALSE.\n\n \\defgroup xTaskCatchUpTicks xTaskCatchUpTicks\n \\ingroup TaskCtrl"]
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n void vTaskResetState( void );\n @endcode\n\n This function resets the internal state of the task. It must be called by the\n application before restarting the scheduler.\n\n \\defgroup vTaskResetState vTaskResetState\n \\ingroup SchedulerControl"]
    pub fn vTaskResetState();
}
unsafe extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
unsafe extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskSwitchContext();
}
unsafe extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCore(xCoreID: BaseType_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskMissedYield();
}
unsafe extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()\n returns an QueueHandle_t variable that can then be used as a parameter to\n xQueueSend(), xQueueReceive(), etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
#[doc = " Type by which queue sets are referenced.  For example, a call to\n xQueueCreateSet() returns an xQueueSet variable that can then be used as a\n parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut QueueDefinition;
#[doc = " Queue sets can contain both queues and semaphores, so the\n QueueSetMemberHandle_t is defined as a type to be used where a parameter or\n return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueueGenericSend(\n                                  QueueHandle_t xQueue,\n                                  const void * pvItemToQueue,\n                                  TickType_t xTicksToWait\n                                  BaseType_t xCopyPosition\n                              );\n @endcode\n\n It is preferred that the macros xQueueSend(), xQueueSendToFront() and\n xQueueSendToBack() are used in place of calling this function directly.\n\n Post an item on a queue.  The item is queued by copy, not by reference.\n This function must not be called from an interrupt service routine.\n See xQueueSendFromISR () for an alternative which may be used in an ISR.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for space to become available on the queue, should it already\n be full.  The call will return immediately if this is set to 0 and the\n queue is full.  The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdPASS if the item was successfully posted, otherwise errQUEUE_FULL.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n uint32_t ulVar = 10U;\n\n void vATask( void *pvParameters )\n {\n QueueHandle_t xQueue1, xQueue2;\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 uint32_t values.\n  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\n\n  // ...\n\n  if( xQueue1 != 0 )\n  {\n      // Send an uint32_t.  Wait for 10 ticks for space to become\n      // available if necessary.\n      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )\n      {\n          // Failed to post the message, even after 10 ticks.\n      }\n  }\n\n  if( xQueue2 != 0 )\n  {\n      // Send a pointer to a struct AMessage object.  Don't block if the\n      // queue is already full.\n      pxMessage = & xMessage;\n      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\defgroup xQueueSend xQueueSend\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueuePeek(\n                           QueueHandle_t xQueue,\n                           void * const pvBuffer,\n                           TickType_t xTicksToWait\n                       );\n @endcode\n\n Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n This macro must not be used in an interrupt service routine.  See\n xQueuePeekFromISR() for an alternative that can be called from an interrupt\n service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n xQueuePeek() will return immediately if xTicksToWait is 0 and the queue\n is empty.\n\n @return pdPASS if an item was successfully received from the queue,\n otherwise errQUEUE_EMPTY.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to peek the data from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Peek a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask, but the item still remains on the queue.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\defgroup xQueuePeek xQueuePeek\n \\ingroup QueueManagement"]
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueuePeekFromISR(\n                                  QueueHandle_t xQueue,\n                                  void *pvBuffer,\n                              );\n @endcode\n\n A version of xQueuePeek() that can be called from an interrupt service\n routine (ISR).\n\n Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @return pdPASS if an item was successfully received from the queue,\n otherwise pdFAIL.\n\n \\defgroup xQueuePeekFromISR xQueuePeekFromISR\n \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueueReceive(\n                               QueueHandle_t xQueue,\n                               void *pvBuffer,\n                               TickType_t xTicksToWait\n                          );\n @endcode\n\n Receive an item from a queue.  The item is received by copy so a buffer of\n adequate size must be provided.  The number of bytes copied into the buffer\n was defined when the queue was created.\n\n Successfully received items are removed from the queue.\n\n This function must not be used in an interrupt service routine.  See\n xQueueReceiveFromISR for an alternative that can.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. xQueueReceive() will return immediately if xTicksToWait\n is zero and the queue is empty.  The time is defined in tick periods so the\n constant portTICK_PERIOD_MS should be used to convert to real time if this is\n required.\n\n @return pdPASS if an item was successfully received from the queue,\n otherwise errQUEUE_EMPTY.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to receive from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Receive a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\defgroup xQueueReceive xQueueReceive\n \\ingroup QueueManagement"]
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );\n @endcode\n\n Return the number of messages stored in a queue.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of messages available in the queue.\n\n \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting\n \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );\n @endcode\n\n Return the number of free spaces available in a queue.  This is equal to the\n number of items that can be sent to the queue before the queue becomes full\n if no items are removed.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of spaces available in the queue.\n\n \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting\n \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n void vQueueDelete( QueueHandle_t xQueue );\n @endcode\n\n Delete a queue - freeing all the memory allocated for storing of items\n placed on the queue.\n\n @param xQueue A handle to the queue to be deleted.\n\n \\defgroup vQueueDelete vQueueDelete\n \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueueGenericSendFromISR(\n                                         QueueHandle_t    xQueue,\n                                         const    void    *pvItemToQueue,\n                                         BaseType_t  *pxHigherPriorityTaskWoken,\n                                         BaseType_t  xCopyPosition\n                                     );\n @endcode\n\n It is preferred that the macros xQueueSendFromISR(),\n xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place\n of calling this function directly.  xQueueGiveFromISR() is an\n equivalent for use by semaphores that don't actually copy any data.\n\n Post an item on a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n Items are queued by copy not reference so it is preferable to only\n queue small items, especially when called from an ISR.  In most cases\n it would be preferable to store a pointer to the item being queued.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task\n to unblock, and the unblocked task has a priority higher than the currently\n running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then\n a context switch should be requested before the interrupt is exited.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdPASS if the data was successfully sent to the queue, otherwise\n errQUEUE_FULL.\n\n Example usage for buffered IO (where the ISR can obtain more than one value\n per call):\n @code{c}\n void vBufferISR( void )\n {\n char cIn;\n BaseType_t xHigherPriorityTaskWokenByPost;\n\n  // We have not woken a task at the start of the ISR.\n  xHigherPriorityTaskWokenByPost = pdFALSE;\n\n  // Loop until the buffer is empty.\n  do\n  {\n      // Obtain a byte from the buffer.\n      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\n\n      // Post each byte.\n      xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );\n\n  } while( portINPUT_BYTE( BUFFER_COUNT ) );\n\n  // Now the buffer is empty we can switch context if necessary.\n  if( xHigherPriorityTaskWokenByPost )\n  {\n       // As xHigherPriorityTaskWokenByPost is now set to pdTRUE then a context\n       // switch should be requested. The macro used is port specific and\n       // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -\n       // refer to the documentation page for the port being used.\n       portYIELD_FROM_ISR( xHigherPriorityTaskWokenByPost );\n  }\n }\n @endcode\n\n \\defgroup xQueueSendFromISR xQueueSendFromISR\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " queue. h\n @code{c}\n BaseType_t xQueueReceiveFromISR(\n                                     QueueHandle_t    xQueue,\n                                     void             *pvBuffer,\n                                     BaseType_t       *pxTaskWoken\n                                 );\n @endcode\n\n Receive an item from a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param pxHigherPriorityTaskWoken A task may be blocked waiting for space to\n become available on the queue.  If xQueueReceiveFromISR causes such a task\n to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will\n remain unchanged.\n\n @return pdPASS if an item was successfully received from the queue,\n otherwise pdFAIL.\n\n Example usage:\n @code{c}\n\n QueueHandle_t xQueue;\n\n // Function to create a queue and post some values.\n void vAFunction( void *pvParameters )\n {\n char cValueToPost;\n const TickType_t xTicksToWait = ( TickType_t )0xff;\n\n  // Create a queue capable of containing 10 characters.\n  xQueue = xQueueCreate( 10, sizeof( char ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Post some characters that will be used within an ISR.  If the queue\n  // is full then this task will block for xTicksToWait ticks.\n  cValueToPost = 'a';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n  cValueToPost = 'b';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n\n  // ... keep posting characters ... this task may block when the queue\n  // becomes full.\n\n  cValueToPost = 'c';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n }\n\n // ISR that outputs all the characters received on the queue.\n void vISR_Routine( void )\n {\n BaseType_t xTaskWokenByReceive = pdFALSE;\n char cRxedChar;\n\n  while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )\n  {\n      // A character was received.  Output the character now.\n      vOutputCharacter( cRxedChar );\n\n      // If removing the character from the queue woke the task that was\n      // posting onto the queue xTaskWokenByReceive will have been set to\n      // pdTRUE.  No matter how many times this loop iterates only one\n      // task will be woken.\n  }\n\n  if( xTaskWokenByReceive != ( char ) pdFALSE;\n  {\n      taskYIELD ();\n  }\n }\n @endcode\n \\defgroup xQueueReceiveFromISR xQueueReceiveFromISR\n \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGenericCreateStatic(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        pucQueueStorage: *mut u8,
        pxStaticQueue: *mut StaticQueue_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGenericGetStaticBuffers(
        xQueue: QueueHandle_t,
        ppucQueueStorage: *mut *mut u8,
        ppxStaticQueue: *mut *mut StaticQueue_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueItemSize(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueLength(xQueue: QueueHandle_t) -> UBaseType_t;
}
pub type SemaphoreHandle_t = QueueHandle_t;
#[doc = " Type by which software timers are referenced.  For example, a call to\n xTimerCreate() returns an TimerHandle_t variable that can then be used to\n reference the subject timer in calls to other software timer API functions\n (for example, xTimerStart(), xTimerReset(), etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t =
    ::std::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: u32)>;
unsafe extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const ::std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::std::os::raw::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    pub fn xTimerCreateStatic(
        pcTimerName: *const ::std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::std::os::raw::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
        pxTimerBuffer: *mut StaticTimer_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    #[doc = " void *pvTimerGetTimerID( TimerHandle_t xTimer );\n\n Returns the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer, and by calling the\n vTimerSetTimerID() API function.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being queried.\n\n @return The ID assigned to the timer being queried.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );\n\n Sets the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being updated.\n\n @param pvNewID The ID to assign to the timer.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );\n\n Queries a timer to see if it is active or dormant.\n\n A timer will be dormant if:\n     1) It has been created but not started, or\n     2) It is an expired one-shot timer that has not been restarted.\n\n Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),\n xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and\n xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the\n active state.\n\n @param xTimer The timer being queried.\n\n @return pdFALSE will be returned if the timer is dormant.  A value other than\n pdFALSE will be returned if the timer is active.\n\n Example usage:\n @verbatim\n // This function assumes xTimer has already been created.\n void vAFunction( TimerHandle_t xTimer )\n {\n     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\"\n     {\n         // xTimer is active, do something.\n     }\n     else\n     {\n         // xTimer is not active, do something else.\n     }\n }\n @endverbatim"]
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );\n\n Simply returns the handle of the timer service/daemon task.  It it not valid\n to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    #[doc = " const char * const pcTimerGetName( TimerHandle_t xTimer );\n\n Returns the name that was assigned to a timer when the timer was created.\n\n @param xTimer The handle of the timer being queried.\n\n @return The name assigned to the timer specified by the xTimer parameter."]
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " void vTimerSetReloadMode( TimerHandle_t xTimer, const BaseType_t xAutoReload );\n\n Updates a timer to be either an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being updated.\n\n @param xAutoReload If xAutoReload is set to pdTRUE then the timer will\n expire repeatedly with a frequency set by the timer's period (see the\n xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If\n xAutoReload is set to pdFALSE then the timer will be a one-shot timer and\n enter the dormant state after it expires."]
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, xAutoReload: BaseType_t);
}
unsafe extern "C" {
    #[doc = " BaseType_t xTimerGetReloadMode( TimerHandle_t xTimer );\n\n Queries a timer to determine if it is an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise\n pdFALSE is returned."]
    pub fn xTimerGetReloadMode(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );\n\n Queries a timer to determine if it is an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise\n pdFALSE is returned."]
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " TickType_t xTimerGetPeriod( TimerHandle_t xTimer );\n\n Returns the period of a timer.\n\n @param xTimer The handle of the timer being queried.\n\n @return The period of the timer in ticks."]
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    #[doc = " TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );\n\n Returns the time in ticks at which the timer will expire.  If this is less\n than the current tick count then the expiry time has overflowed from the\n current time.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is running then the time in ticks at which the timer\n will next expire is returned.  If the timer is not running then the return\n value is undefined."]
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn xTimerGetStaticBuffer(
        xTimer: TimerHandle_t,
        ppxTimerBuffer: *mut *mut StaticTimer_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromTask(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromISR(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " task.h\n @code{c}\n void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, configSTACK_DEPTH_TYPE * puxTimerTaskStackSize )\n @endcode\n\n This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer\n @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task\n @param puxTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetTimerTaskMemory(
        ppxTimerTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxTimerTaskStackBuffer: *mut *mut StackType_t,
        puxTimerTaskStackSize: *mut usize,
    );
}
unsafe extern "C" {
    pub fn vTimerResetState();
}
