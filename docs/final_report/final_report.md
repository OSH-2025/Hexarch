## C模块添加——文件模块（FatFS）

### 实现的主要功能
- **初始化**：包括磁盘格式化、文件系统的挂载与卸载。
- **文件操作**：如文件的创建、写入、读取、关闭等。
- **目录操作**：如目录的创建、遍历等。

### 带来的好处
- **轻量级设计**：核心仅7个文件，代码体积小，适合嵌入式系统。
- **跨平台兼容性**：在多种嵌入式平台上运行（比如ARM、RISC-V 等等），同时，支持标准的 FAT12/16/32 文件系统格式。
- **模块化与易移植**：FatFS 将文件系统逻辑与底层硬件驱动完全分离，我们在移植的过程中不需要修改核心代码，所以说它的移植难度大大降低
- **丰富的API**：提供标准化的文件/目录操作接口，易于上手。
- **稳定可靠**：经过广泛应用和验证，社区活跃，文档完善。
- **开源免费**：无商业授权限制，便于二次开发。

### 整体实现思路
- **核心文件**：  
  - `ff.c`、`ff.h`、`ffconf.h`（配置）  
  - `diskio.c`、`diskio.h`（配置头文件，通过修改其中的宏定义可以裁剪和定制文件系统功能）  
  - `ffsystem.c`（实现了操作系统的依赖函数，主要处理了内存分配和互斥锁，使FatFS和FreeRTOS更好结合）  
  - `ffunicode.c`（Unicode编码支持模块，提供了字符编码转换功能，支持长文件名和多语言环境）
- **分层架构**：  
  1. **应用层**：对外提供API（如`f_mount`、`f_open`、`f_read`、`f_write`等），用户可以通过简单的函数调用来操作文件系统，不需要了解底层的实现细节
  2. **文件系统逻辑层**：`ff.c`和`ff.h`实现FAT文件系统的核心逻辑。
  3. **底层设备驱动层**：`diskio.c`和`diskio.h`负责与实际存储介质交互。本项目中以RAM磁盘为例，通过内存数组模拟存储设备，便于开发和调试。

### 为什么选择RAM磁盘
- **无需依赖物理设备**，调试和开发更灵活。
- **读写速度快**，资源消耗低。
- **便于后续切换**到MMC/SD卡或USB等实际存储设备，只需修改底层驱动部分。

RAM 使用了系统的内存模拟磁盘，而 MMC 和 USB 需要依赖实际物理设备。

RAM 无需外部硬件，避免硬件配置的干扰，调试过程简单，而且直接访问内存的读写速度相对较高而且稳定，适合实时系统测试。RAM 会面临占用内存过大的问题，我们可以修改 ffconf.h 中的有关参数，修改磁盘扇区数量，使用静态分配代替动态分配（减少内存碎片），精简 FatFS 的功能等等，其实后续实际使用过程，大概都是要改用硬件的，这里选择 RAM 其实只是为了方便快速测试。

### 移植与集成过程
1. **配置**：根据项目需求修改`ffconf.h`中的相关宏定义。
2. **驱动适配**：实现或修改`diskio.c`中的关键函数（如`disk_initialize`、`disk_status`、`disk_read`、`disk_write`、`disk_ioctl`），使其适配RAM磁盘。
3. **功能测试**：在`main.c`中添加测试任务，验证文件系统的初始化、文件/目录操作等功能。

一开始单独部署测试FatFS时采用的是（虚拟磁盘镜像文件），而后续采用的是 RAM 

虚拟磁盘镜像文件存在问题：

1. 需要宿主操作系统的文件系统支持
2. 底层接口需要重写，移植困难
3. 资源需求高（需要文件I/O库支持，增加代码体积与内存占用）

### 运行实例

```
[FatFs]测试开始...
[FatFS]正在格式化磁盘...
[FatFS]格式化成功
[FatFS]正在挂载文件系统...
[FatFS]文件系统挂载成功！
[FatFS]FAT类型: FAT12
[FatFS]测试1: 创建并写入文件'TEST.TXT'...
[FatFS]写入成功: 42字节
[FatFS]测试2: 读取文件'TEST.TXT'...
[FatFS]读取成功: 42字节
[FatFS]文件内容: 这是一个FatFS文件系统测试文件.
[FatFS]测试3: 创建目录'TESTDIR'...
[FatFS]目录创建成功或已存在
[FatFS]测试4: 列出根目录内容...
[FatFS]文件：TEST.TXT，大小: 42字节
[FatFS]目录：TESTDIR
[FatFS]测试完成，卸载文件系统
[FatFS]FatFS集成测试成功完成！
```



## Rust改写

### 顶层结构与启动流程
- start.S（汇编启动文件）：这是系统上电后执行的第一段代码，它的核心职责非常纯粹：
  - 设置初始栈指针：为后续的rust代码执行环境准备一个有效的栈空间
  - 跳转到rust入口：完成最基本的硬件初始化后，通过call指令跳转到rust代码的入口点
- fake_rom.lds（链接器脚本）：该文件指导链接器如何组织编译后的各个代码和数据段，生成最终的可执行文件。精确定义了内存布局：
  - .text段，.rodata段，.data段，.bss段
  - 定义了堆和栈起始和结束地址，为动态内存分配和任务栈的创建提供依据
- main.rs（主函数）：这是代码主要执行的部分，也是模拟后显示的部分。
### base模块：内核基础与配置
- FreeRTOSconfig.rs：这是freertos官方的FreeRTOSConfig.h的rust版本，用于配置内核。通过pub const定义了一系列编译常量，用于裁剪和配置内核功能。
- projdefs.rs：等同于C版本中的projdefs.h。项目范围内的通用常量和类型别名。
- allocator.rs:实现了全局动态内存分配器，在no_std环境下必须提供一个堆内存分配器的实现，定义堆的起始和结束位置，为整个系统提供malloc和free的能力
- kernel.rs：包含了一些核心的内核全局函数和宏，是其他模块都会依赖的东西
### tasks模块：任务管理与调度
RTOS的心脏，负责任务的创建、调度、状态管理和上下文切换。
- types.rs:定义了与任务相关的所有核心数据结构
  - tskTaskControlBlock(TCB):这是描述一个任务所有信息的结构体，包括任务状态，栈顶指针，任务名称等等
  - TaskHandle_t：在rust中，任务句柄被安全地定义为pub type TaskHandle_t = Arc<RwLock<tskTaskControlBlock>>
    - Arc：原子引用计数智能指针，允许多个地方（如就绪列表、阻塞列表、用户代码）安全地“拥有”同一个TCB的引用，当所有引用都消失的时候，TCB才会被销毁
    - RwLock：读写锁，确保了对TCB内部数据的并发访问是安全的，写必须独占，读取可以并发。防止数据竞争creation.rs：负责任务的创建
- creation.rs：负责任务的创建
  - xTaskCreate：实现了动态任务创建，它会：
    - 从我们定义的堆中分配任务栈和TCB
    - 调用prvIntialiseNewTask 初始化TCB，包括设置任务入口函数、名称、优先级等。
    - 初始化任务的栈帧
  - xTaskCreateStatic：实现了静态任务创建，任务栈和TCB的内存由编译时提供，避免运行时动态内存分配
- scheduler.rs：实现了调度器
  - vTaskStartScheduler()：启动调度器的函数。它会创建空闲任务，配置定时器以产生系统时钟节拍，并启动第一个任务的执行，将CPU的控制权移交给调度器
  - 调度逻辑：调度器维护多个优先级的就绪列表（READY_TASK_LISTS）。当需要进行任务切换时（例如，在时钟中断或任务阻塞后），它会从最高优先级的就绪列表中选择下一个要运行的任务，并执行上下文切换。
- control.rs：包含任务控制相关的API。
  - vTaskDelay/xTaskDelayUntil：将当前任务置于阻塞状态一段制定的时间。实现上，它会将任务从就绪列表中删除，并插入到延时列表（DELAYED_TASK_LIST）中。
  - vTaskSuspend/vTaskResume：挂起和恢复任务。通过在不同状态列表（如挂起列表）之间移动任务的TCB来实现
  - vTaskEnterCritical/vTaskExitCritical：进入和退出临界区，通过禁用和启用中断来实现，确保一段代码的原子执行。
### list模块
- FreeRTOS大量使用一种高效的双向链表来管理任务，我们用Rust对其进行了安全的封装
- list.rs：
  - 数据结构：定义了ListT（链表本身）和ListItemT（链表节点）。同样地，节点之间的链接使用了Weak和Arc来代替原始指针，防止了悬垂指针的循环引用导致的内存泄漏问题。
  - API：提供了vListRemove等一系列与C版本兼容的链表操作函数，这些函数内部封装了所有权的移动和借用检查，对外暴露了安全易用的接口，例如，就绪列表，阻塞列表，挂起列表都是使用的ListT
### queue、semphr、event_group：任务间通信
- 这些模块提供了任务间同步与通信的核心机制
- queue.rs：队列是FreeRTOS中最基础的IPC机制。
  - QueueDefinition：队列的核心结构体，包含了存储区指针、项目大小、消息数量以及两个重要的列表：
    - xTasksWaitingToSend：因队列满而阻塞的发送任务列表
    - xTasksWaitingToReceive：因队列空而阻塞的接收任务列表
  - xQueueSend（）：当任务向一个已满的队列发送数据时，如果设置了阻塞时间，该任务的TCB会被从就绪列表移除，并添加到队列的xTaskWaitingToSend列表中，然后触发一次任务调度。
  - xQueueReceive（）：当任务从一个空队列接收数据时，同样会被阻塞并加入到xTaskWaitingToReceive列表，当另一个任务向该队列发送数据后，会检查此列表，唤醒其中等待的任务（即将其移回就绪列表）。
  - 锁机制：对队列内部数据访问，都通过taskENTER_CRITICAL!和taskEXIT_CRITICAL！宏来保护，确保多任务并发操作队列的原子性
- semphr/semphr.rs：信号量和互斥锁。在FreeRTOS中，它们是基于队列实现的特例。
  - xSemaphoreCreateBinary（）：创建一个二进制信号量，本质上是一个长度为1的队列
  - xSemaphoreCreateMutex（）：创建一个互斥锁，它也是一个长度为1的队列，但额外包含了优先级继承的逻辑，以防出现优先级反转的问题
  - xSemaphoreTake（）/xSemaphoreGive（）：获取和释放信号量/互斥锁，其内部实现最终调用的是xQueueReceive和xQueueSend
- event_group/event_group.rs：事件组，提供了一种多对多的任务同步机制。任务可以等待一个或多个事件的发生，其实现内部也维护了一个等待任务列表，当事件被设置时，会遍历该列表，检查是否有任务等待条件被满足，并唤醒它们。
portable目录：平台移植
这个目录包含所有与具体CPU架构和开发板相关的代码，使得内核核心代码可以独立于硬件平台
- portmacro.rs：定义了与平台相关的宏和类型
- portable.rs：实现了上下文切换的核心函数pxPortInitialiseStack（初始化任务栈）和xPortStartScheduler（启动调度器的底层实现）。上下文切换通过内联汇编（asm！）实现，精确地保存和恢复所有通用寄存器。
- riscv_virt.rs：针对QEMU的 virt RISC-V虚拟开发板的特定代码：
  - vSendString：实现了通过向NS16550 UART串口设备的内存映射地址写入数据，来在QEMU控制台打印字符串的函数，也是一种调试手段
  - 中断处理




## Rust模块添加
我们同样把fatfs的C语言版本加进了rust版的FreeRTOS中，如同c版本的一样，同样是使用内存模拟磁盘，主要增加了fs文件夹，其中的rust代码是改写自fatfs官方所提供的c语言文件，加入后，对build.rs进行修改，并且在用到的地方引入mod fs，即可运行这个文件系统。
进行了简单的测试，在这里，设置了三个任务，优先级由高到低，把文件系统的任务优先级设为最高，并且在次优先级的两个任务中，在运行一段时间后都挂起，所以，在高优先级任务启动后，会转入空闲任务（这个任务是在没有任务执行时，自动执行的，这是一种最大化利用率的方式，空闲任务可以干一些用户自己设计的事），然后低优先级任务运行，挂起后会，再次转入其他任务，实现两个任务交替完成的效果。
结果如下图:
![alt text](png/image-1.png)


## 困难与解决
- 调试与错误处理：
  - 在开发裸机程序时，由于nostd环境，我们失去了操作系统提供的一切便利，包括最基本的 printf。当系统无法启动、或在某个地方崩溃时，我们就像在黑暗中摸索，没有任何信息反馈。
  - 调试:GDB 远程调试: 首先是需要安装gdb调试工具（这里不是普通的gdb工具，而是适配RISC-V架构的）通过在 makefile 中配置 make debug 命令，可以启动一个等待 GDB 连接的 QEMU 实例。我们使用 riscv32-unknown-elf-gdb 连接到该实例，可以进行设置断点、单步执行、查看内存和寄存器等所有标准调试操作。
  - 串口打印: 我们实现了简单的串口输出功能，通过 rustPrint FFI 函数，可以在 QEMU 控制台打印调试信息，这是最直接有效的调试手段。
  - 编译时错误: 大部分逻辑错误、类型不匹配、数据竞争和内存安全问题，都在编译阶段被 Rust 编译器发现并报告，极大地减少了运行时 bug，这也是rust语言的优势之一，对于出现的编译错误，如果是一些简单的语法错误，大多数情况下，编译器都会有精确的输出和“预测”的解决方案。
  - Panic 处理: 我们定义了一个全局的 panic_handler。当程序遇到不可恢复的错误（panic）时，会进入该处理器，它会通过串口打印出panic，然后进入死循环，防止系统继续执行错误代码。
- 全局可变状态的管理: RTOS 内核中存在大量全局状态（如任务列表、调度器状态）。在 C 中通常使用全局变量，但这在 Rust 中是极其不安全的。
  - 解决方案: 我们采用 lazy_static! 宏来安全地初始化全局静态变量，并使用 spin::Mutex 或 RwLock 对其进行封装，确保了对全局状态的访问是互斥和线程安全的。
- C 语言精巧数据结构的 Rust 安全重构
  - FreeRTOS 的性能优势部分来源于其精巧的数据结构，特别是其侵入式双向链表。在 C 语言中，链表节点直接嵌入在任务控制块（TCB）中，通过指针操作直接链接，非常高效但也极易出错（如错误的指针操作导致链表断裂或产生循环）。用 Rust 的标准库集合（如 Vec 或 LinkedList）直接替换，可能会有性能损失或不符合 RTOS 的需求。
  - 我们的解决方案: 我们重新设计并实现了安全的、符合 Rust 范式的链表。
    - 所有权与智能指针: 我们没有使用裸指针，而是使用了 Arc<RwLock<ListItemT>> 和 Weak<RwLock<ListItemT>>。Arc 用于强引用（如链表头指向第一个节点），Weak 用于弱引用（如节点间的 prev 指针），这巧妙地解决了循环引用问题，防止了内存泄漏。RwLock 则保证了对节点内容并发访问的安全性。
    - 封装为模块: 我们将整个链表的实现封装在 list 模块中，对外提供与 C 版本功能一致的安全 API（如 vListInsertEnd），而将所有复杂的指针和所有权操作隐藏在模块内部。
    - 在上面举过双向链表的例子，这就是一个最典型的C语言数据结构
